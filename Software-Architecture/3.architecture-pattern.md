#  软件架构模式



## 一. 什么是 架构模式

**架构模式**  是一系列 **不断** 在实践中使用的 **设计决策** 的集合，并且是由一些便于进行 **重用** 的特性进行描述的架构。 

总结来说就是人们在实际的软件开发中发现的非常好用并且经常使用的设计决策和方法，  架构模式 是被 **发现** 的，不是被 **发明** 的。 在新的开发情景下，总会有新的 **架构模式** 出现。 

**《Software Architecture in Practice》**  中定义的 描述 **架构模式** 的 **三元组**：  **情景**，**问题**， **解决方案**

- **情景：**  一个可以 **复现** 的， **普遍**的 现实中问题发生的环境。
- **问题：** 要说明问题要求的 **质量属性** ， 和遇到的 **困难**。
- **解决方案:**  主要包括 **一系列的元素种类**， 一系列的 **连接件**或者**交互机制**， 组件之间的 **布局**， 上述的一些 **限制** 。 

## 二. 分层模式

- **情景：** 开发 **大型复杂系统** 需要将系统中的模块分离进行 **独立开发**

- **问题：** 软件需要以一种模块之间 **关联和依赖最小** 的方式进行模块划分，以支持 **可移植性**， **可修改性** 和 进行**复用**。

- **解决方案：**  把整个软件划分成 层，每一层都提供一种有内聚性的服务。 层和层之间的相互调用是单向的， 不允许 **跨层调用** ， 也不允许 **下层调用上层**。

    

​     分层 会增加 **成本** 和 **复杂度** ， 并且会对系统造成 **性能损失**，因为即使是一个上层的一个非常简单的功能调用也要经过层层的调用才能完成。  

​	

​	分层模式非常普遍， 这里也就不 太详细去描述了， 最常见的分层就是 **UI**， **业务逻辑** ， **数据库** 的分层方式。 

## 三. Broker 模式

- **情景： ** 很多系统是由分散在 **不同服务器** 上的服务构建而成的， 实现这样的系统的复杂程度在于必须要去考虑 **系统如何和其他的系统进行交互**， 并且其他的系统的**可用性**会对我们的系统 **直接产生影响**。 （隐含了一些**面向服务** 的思想）
- **问题：**  如何让服务的使用者不需要知道服务提供者的细节，并且可以灵活的建立服务提供者和服务服务使用者的绑定关系。 
- **解决方案：** 通过一个 **Broker** 的角色把服务的使用者和服务的提供者进行分离。  用户向 中间人发起请求，  中间人根据请求找到最合适的服务提供者。

**Broker 模式是一种典型的分布式模式**

优点： 

1. 当一个服务器不可用的时候， Broker 可以灵活的选择其他相似的服务。 
2. 如果有新的服务器加入，不需要对用户进行更改。
3. Broker 可以灵活选择最快速的服务器，提升了系统的性能。 



缺点： 

1. 增加了设计的复杂度， 必须去设计更多的代理人和一些消息协议。 
2. 多增加了一层，会增加通讯延迟，对性能有影响。 
3. 情景复杂， 错误情景很难复现，导致可测试性不高。 
4. Broker 容易成为被攻击的对象， 并且 Broker 容易单点失效。 
5. Broker 也可能成为性能的瓶颈所在。 
6. 用户和服务者的隔离会 影响 本来 可以对 服务提供者 做的特定的优化， 从而间接的影响了性能。 



**Broker 模式的示意图如下图所示**

包括 client, client-proxy, broker, bridge, server, server-proxy 6个部分。 

其中 client-proxy 和 server-proxy 是对服务的封装，使得调用远程方法就如同调用本地方法一样， 如同 **RMI**

Bridge 用来连接 各个 Broker,  当系统的实现特别复杂的时候，可能会需要这个角色。 

<img src="https://exlaw.github.io/assets/img/architecture/img1.png" alt="drawing" width="100%"/>



**Broker 模式在实际中的应用:**

1. **消息队列（MQ）**

   **消息队列** 是的主要应用场景是将一些比较耗时并且不需要同步的结果 放入队列中，等待调用相关的服务。  所以 消息队列 其实就承担了 Broker 的角色。 

   下图就简单的说明了消息队列中的 Broker 模式。 

   <img src="https://exlaw.github.io/assets/img/architecture/img2.png" alt="drawing" width="100%"/>

2. **EJB（Enterprise JavaBean )**

   **EJB** 是 JavaEE 中面向服务的体系架构的解决方案，可以将功能封装在服务器端，以服务的形式对外发布， 客户端可以在无须知道具体的实现细节的情况下调用远程方法。   EJB 更像是提供了一种接口的规范，比如java 中的 **RMI** 和**JDNI** 进行相关服务的调用。   

   个人理解， EJB 承担了各种复杂的业务的定义和交流，调用等，所以也可以被看作是一个 **Broker** ？ 





## MVC 模式

**情景:**  交互频繁的 用户界面 部分是软件中变更最频繁的部分， 所以让用户界面部分的变化不影响实际的系统数据的变化十分重要。   还要能够支持使用不同的方式展示相同的数据，数据变化的时候展示也能够进行实时更新。 

**问题:** 如何让用户界面部分和系统的实际功能部分完全分离， 如何能够使得数据发生变化的时候多套用户界面全都发生改变。 

**解决方案:** 

MVC 模式， 设置了3种组件

- Model: 存储系统中的数据
- View:  展示系统中的数据并且和用户进行交互
- Controller: 在Model 和 View 中间，再负责在系统的状态改变的时候进行通知。 

**一些小问题:** 

1. 对与相对简单的界面系统，实现成本可能相对较高。 
2. 一些用户界面库和 MVC 模式之间可能不是完全兼容。

MVC 组件之间的通讯一般是使用事件或者回调的方式进行的。 

MVC 组件时间的耦合度非常底，所以非常方便进行平行的测试，并且一个组件的改变对其他组件的影响不会非常大。 

下图就是 MVC 模式的一般结构。

<img src="https://exlaw.github.io/assets/img/architecture/img4.png" alt="drawing" width="100%"/>

下面是一个简单的计数器系统的 MVC 实现方式。 

首先是 Model 部分，counter 变量就是系统的数据。  Model 继承了 Observable,   也就是 MVC 中隐含着 观察者模式， notifyObservers 方法通知相应的观察者。  

```java
public class Model extends java.util.Observable {	
	
	private int counter;	//primitive, automatically initialised to 0

	public Model(){

		System.out.println("Model()");

	} 

	public void setValue(int value) {
		this.counter = value;
		System.out.println("Model init: counter = " + counter);
		setChanged();
		notifyObservers(counter);
	} 
	
	public void incrementValue() {
		++counter;
		System.out.println("Model     : counter = " + counter);
		setChanged();
		notifyObservers(counter);
	}	
} 
```

然后是 View 部分,  update 方法作为观察着模式的更新方法。 

```java
import java.awt.Button;
import java.awt.Panel;
import java.awt.Frame;
import java.awt.TextField;
import java.awt.Label;
import java.awt.event.WindowEvent;
import java.awt.event.WindowAdapter;	
import java.lang.Integer;
import java.util.Observable;

class View implements java.util.Observer {

	private TextField myTextField;
	private Button button; 
	View() {
		System.out.println("View()");	
		Frame frame 		= new Frame("simple MVC");
		frame.add("North", new Label("counter"));
		myTextField 		= new TextField();
		frame.add("Center", myTextField);
		Panel panel 		= new Panel();
		button	 		= new Button("PressMe");
		panel.add(button);
		frame.add("South", panel);		
		frame.addWindowListener(new CloseListener());	
		frame.setSize(200,100);
		frame.setLocation(100,100);
		frame.setVisible(true);
	}
    public void update(Observable obs, Object obj) {
		myTextField.setText("" + ((Integer)obj).intValue());
    }
	public void setValue(int v){
    	myTextField.setText("" + v);
	}
    	
	public void addController(Controller controller){
		System.out.println("View      : adding controller");
		button.addActionListener(controller);	
	} 
	
	public static class CloseListener extends WindowAdapter {
		public void windowClosing(WindowEvent e) {
			e.getWindow().setVisible(false);
			System.exit(0);
		} 
	}

}
```

最后是 Controller 部分：

```java
class Controller implements java.awt.event.ActionListener {

	Model model;
	View view;

	Controller() {	
		System.out.println ("Controller()");
	}

	public void actionPerformed(java.awt.event.ActionEvent e){
		System.out.println("Controller: acting on Model");
		model.incrementValue();
	}
    
	public void addModel(Model m){
		System.out.println("Controller: adding model");
		this.model = m;
	}

	public void addView(View v){
		System.out.println("Controller: adding view");
		this.view = v;
	}

	public void initModel(int x){
		model.setValue(x);
	}

}
```

驱动代码,  明确各个部分之间的关系： 

```java
public class RunMVC {
	private int start_value = 10;	

	public RunMVC() {
		Model myModel 	= new Model();
		View myView 	= new View();
		myModel.addObserver(myView);
		Controller myController = new Controller();
		myController.addModel(myModel);
		myController.addView(myView);
		myController.initModel(start_value);
		myView.addController(myController);
	} 
} 
```



从上面可以看到 MVC 模式也不同于简单的分层， Model 和 View 之间是存在耦合关系的， 但是这种耦合关系被观察者模式给最大限度的降低了。 

**MVC 在实际的项目中的运用**

1. java 的 Swing 库就是 MVC 模式的最典型的应用。 
2. ASP.NET 采用了 MVC
3. Nokia's Qt framework

## Pipe-and-Filter 模式

**情景:**  很多系统要对不同数据对象进行数据流转换，有时候这些转换在实际中非常普遍，所以由必要把这些抽象成独立的，可以重用的组件。
**问题:**  很多系统需要被分成可以重用的，低耦合的组件。 这些组件要求可以非常灵活的和其他的组件进行组合， 并且很容易进行重用。 组件之间相互独立也让组件可以进行并行的计算。 
**解决方案:** 数据之间交互的方式是流式数据连续不断的转换， 数据到达 filter 的输入端口，转换之后 从 filter 的输出端口 经过 一个 Pipe 到达下一个 Filter。 

**缺点:**

1. 不利于实时性要求比较强的系统（不允许回调，并且处理的步骤比较长）
2. 长期进行计算需要加一些保存点，否则单点失效容易造成整个系统的失效

## Client-Server 模式

**情景:** 大量的分布用户希望去共享一些资源或者服务，并且能够对服务的访问和质量做出一些控制。
**问题:** 通过管理一些分享的资源或者服务，可以提升可修改性和重用性，因为我们可以把这些资源或者服务集中起来进行使用。 
**解决方案:**  两个基本组件， client 和 server， 最基本的连接方式是通过一些 请求/回复 协议驱动的数据连接件。 

**缺点:**

1. server 会成为性能的瓶颈， 容易单点失效导致整个系统失效。 
2. 把功能做在 client 还是 server 这样的决定一旦做出就不太容易进行修改。 

**常见的模式应用:**

1. 信息系统， client 是用户界面系统， server 是数据库管理系统。
2. Web 应用， 浏览器是 client

对 server 进行扩增就是分布式应用，可以有效的提升可用性。

## Peer-to-Peer 模式

**情景:** 在通讯和提供资源对角度上同等重要的 分布式计算实体，需要合作去给不同地区的用户提供服务。
**问题:** 平等的计算实体如何在保证高可用性和高扩展性的情况下彼此之间通过共同的协议进行交流以提供他们的服务。 
**解决方案:** 每个组件直接和其余的组件进行交互，所有的组件都是平等的，没有对于整个系统有决定性作用的组件。  通讯方式也是传统上的请求回复方式 但不是 client-server 种的非对称方式. 每个 peer 都同时是 client 和 server。 所有的 peer 使用相同的服务，并且使用相同的协议。 

一个 peer-to-peer 架构一般会有若干有索引和搜寻能力的超级节点，能够让一个正常节点找到其他更多的节点。 

由于多个Peer 可以提供相同的服务，所以在一个 Peer 不可用的时候，可以由其他的 peer 进行代替，这样就很大程度上的提升了系统的可用性。 

Peer-to-Peer 也会使得分配在每一个peer上的性能压力变小，从而从整体上提升系统的性能。 

**缺点:**

1. 管理安全性， 数据的一致性， 数据和服务的可用性都会非常的复杂。 
2. 系统的质量属性提高保证，只能通过概率的方式进行预测。 





## Service-Oriented Architecture 模式

**情景:** 大量的服务被服务生产者提供，被用户使用。 服务的用户需要在不需要知道这些服务的实现细节的情况下去使用这些服务。

**问题:** 我怎么样提高 在不同平台上， 使用不同的编程语言制作的， 由不同的组织提供， 分布在整个互联网上的组件的互操作性。 如何去使用不同的服务并且组合起来还要有不错的性能，安全性，和可用性。

**解决方案:** SOA pattern 描述了一系列使用和提供服务的组件。 每个组件有描述其他组件提供的服务的描述的接口。 Service-level aggrement 可以来保证服务的质量。 一个组件通过请求不同的服务来完成功能。 

一个SOA 应用必须还要使用一些提高基础服务的中间件组件。

- 一个服务的调用必须由一个 ESB(enterprise service bus) 来进行中间调解。 一个ESB在服务的提供者和服务的使用者之间传递信息。 并且一个 ESB 可以把信息从一种语言或者协议变成另一种，进行安全检查，管理事务。 使用ESB 促进了互操作性。安全性和可修改性。 但是同时也增加了通讯的开销，对性能有一定的影响。  当ESB失效的时候，服务的使用者和消费者也可以进行点对点的通讯。 
- 可以使用服务注册表（service refistry）来提升服务提供者的独立性。 注册表是一个可以允许服务在运行时被注册的基本组件。 这样可以在运行时发现服务，有效的提升了系统的可修改性，一个服务注册表甚至可以允许同一时间同一个服务可以有不同的版本。
- Orchestration server 管理在一个SOA系统中不同的服务消费者和提供者之间的交互。 在特定事件发生的时候会执行脚本。 对和外部的组件或系统交互的业务流程或者工作流定义的非常好的系统可以在使用 Orchestration server 的时候取得非常好的互操作性，和可靠性。 很多商业上可用的 Orchestration server 支持很多不同的工作流和业务过程语言模型。

 在SOA系统中一些通用的连接组件

- SOAP： web服务通讯的标准协议，通过HTTP协议进行交换XML格式的信息。
- Representational State Transfer(Rest): 使用标准的 HTTP 协议， 通过使用基本的HTTP 方法（POST, GET, PUT, DELETE） 来进行请求服务。
- 异步消息通讯， 一种发完消息就不管了的方法。 参与不必等待对方收到信息的确认，基础的设施已经默认了信息已经成功ing进行了传输。 消息通讯的连接组件可以是点对点的，也可以是发布，订阅模式。 

 实际中的SOA环境可能采用多种混合的连接方式。 一些 消息队列（MQ） 实际上是提供了一些异步的消息通讯。 

 **缺点:**

1. 设计和实现非常复杂
2. 由中间件造成的性能延迟，和过于依赖其他服务导致的性能难以保证。
3. 和Broker模式相同的缺点， 因为设计的理念和目标和Broker模式是类似的。 

**优点**

1. 互操作性非常强， 服务提供者和使用者的差异性可能非常大。 

下面是一个使用了SOA的系统： Adventure Builder.

这个系统允许用户通过选择各种活动或者交通方式来组成一次旅行。 这个系统和很多外部的服务提供者进行进行交互来完成功能，  比如要和银行系统，订单系统，交通系统，活动系统进行通信和使用服务。  使用SOAP的方式可以方便的完成这样的互操作通信。 

   <img src="https://exlaw.github.io/assets/img/architecture/img5.png" alt="drawing" width="100%"/>

## Publish-Subscribe 模式

**情景:** 有很多相互独立的数据的生产者和使用者必须进行交互。 数据的生产者和使用者和交互的数据都是不确定的。 

**问题:** 如何确定一套完整的能够支持数据的生产者和使用者进行相互交互并且生产者和使用者之间不需要彼此之间相互了解长度机制。 

**解决方案:** 在publish-subscrib 模式中，组件之间通过事件进行交互。 组件必须订阅一系列的事件，然后由 publish-subscrib 的运行时基础设施 来确保发布的事件被传递到所有的订阅者。 主要的连接方式就是事件总线（event bus）。 发布者发布事件到总线上，总线负责把事件给订阅者。 

**缺点：**

1. 由不确定的事件延迟，适合异步系统，实时性不高， 并且很难有十分复杂的交互。 

Publish-Subscrib 的计算模型最好可以被想象成独立的进程或者物体，和在环境中产生的事件进行交互，最终和其他的组件进行交互。 

下面是一个Public-Subcsrib 模式的例子。 

 <img src="https://exlaw.github.io/assets/img/architecture/img6.png" alt="drawing" width="100%"/>

 一些实际的应用还有

- 图形用户界面， 用户的低层次输入被认为是事件传给事件处理器。 
- MVC应用:  其中的观察者模式就是非常好的例子
- ERP系统：  集成了很多组件，每个组件只接受一部分事件。 
- 扩展编程环境，工具之间通过事件进行交流。 
- 邮件系统： 典型的应用，用户只收到自己注册的事件。
- 社交网络， 一个朋友的动态更新了自己会收到通知。

 Publish-subscrib 模式实际中有好多种形式：

1. 基于列表的发布和订阅，每个发布者维护一个订阅列表。 可修改性不高，性能还行。
2. 基于广播的发布和订阅。 发布者不知道发给谁，采用广播的方式，订阅者判断是否接受。 可能有潜在的不高效的问题。 
3. 基于内容的发布和订阅，可以说是基于主题的。  通过内容的标签进行判断。 

 在实际中 Publish-subscrib 模式会由一些 面向信息的中间件组成，中间件可以被看成是一个 Broker。 中间件还要定位，存储和转换数据。 所以这个模式其实和broker模式由很多相似之处。

## Shared-Data 模式

**情景:**  很多个系统组件需要共享和操作大规模的数据， 这些数据不属于任何一个系统

**问题:**  系统是怎样存储操作可以被大规模访问的数据的。 

**解决方案:** 在 Shared-data 模式中， 数据交换主要是 数据访问器 和 至少有一个的 共享数据仓库之间的。 通用计算模型是数据访问器从数据仓库中拿到数据并且向数据仓库中写入一条或者更多的数据。  在纯的 Shared-data 系统中， 数据访问器之间只能通过数据仓库进行交流。  实际应用中可能会打破这个准则。  

**缺点:**

1. 数据仓库可能会成为性能瓶颈
2. 可能会因为单点故障导致整个系统失效
3. 数据访问器和数据仓库的耦合可能太紧密了

**优点**

1. 将数据的提供和使用接耦，这一点对可修改性有积极的影响

下面是一个 Shared-data 的例子，这个例子中有一个中心存储的数据仓库，数据的访问器有各种个样的客户端。 
 <img src="https://exlaw.github.io/assets/img/architecture/img7.png" alt="drawing" width="100%"/>

## Map-Reduce 模式

 **情景:**  业务中需要去快速的去处理和分析超大规模的数据。 并且这样的程序应该容易书写，运行起来非常高效，对硬件失效也能有非常好的应对。 

 **问题:** 对于大多数有超大规模数据的系统，对数据进行排序并且分析分类好的数据是非常有效的。 Map-reduce pattern 就是要使用一个分布式的并行排序算法高效的解决这个问题并且提供一个让程序员非常容易对数据进行分析的方法。

 **解决方案:** Map-reduce 模式有三部分， 第一部分是一个能够在大规模并行计算的环境下灵活的将软件分派到硬件节点上的定制基础设施并且需要的时候能够处理这些数据的排序。  硬件节点可能是独立的处理器也可能是多核处理器。  第二个第三个部分是两个非常重要的函数， map 和 reduce。

 map函数接受一个 key 和一个 数据集作为输入，map函数的目的是对数据集进行过滤和排序。 所有的复杂分析都要在reduce函数中完成，

 一个数据是否会在之后的进一步处理中呗用到要看map函数。 第二个key 对于map函数也十分的重要， 这是用于排序的key，map 函数的输出就是<key2, value>。

 排序是由map 函数和 基础的结构联合执行的。 得到的每条数据都由 key2 进行哈希进入一个硬盘分区中， 基础结构保留了key2的索引文件，这样使得硬盘里的数据可以被重新组合成 key2 的顺序。

 map部分的性能提升可以通过增加map实例的数量达到，每一个都处理不同硬盘分区中的数据。 

 reduce 函数做一些程序中规定的（业务规定）的分析，然后产生结果。   结果集几乎总是比输入的集合要小，所以这个过程也叫做reduce. 

  <img src="https://exlaw.github.io/assets/img/architecture/img8.png" alt="drawing" width="100%"/>

下面是不适合使用过 Map-reduce 模式的情况： 

- 如果你没有一个很大数据集，完全没有必要使用map-reduce.
- 如果你不能把你的数据分成很多更小的子集，那么map-reduce的优势就没有了。
- 如果你由需要很多 reduce 函数的操作，那么掌控起来会非常复杂。

Map-reduce 的商业实现 提供了一套能够把函数实体映射到硬件上， 从硬件的错误中恢复， 还有一些比较好的排序工具。 

## Multi-tier 模式

**情景:** 在一个分布式部署函数中，通常会有把系统的基础结构放到不同的子集中的需要。 可能由于操作上的或者商业上的原因。 （不同基础的组件可能属于不同的公司）

**问题:** 我们怎么才能将系统分解成更多的计算独立的计算结构， 一系列软件和硬件的集合， 由一些交流媒介相互联系。 这样做的目的是进行特定的服务器环境的优化来满足一些操作需求和资源的使用。 

**解决方案:** 系统的计算结构是由一些列的计算组件构成的， 每个被成为一个 tier, 把组件的集合变成一个 tier 由很多不同的标准。

tier 可以被映射到很多运行时组件中，及时在事件中最经常被用到的是 client-server 的模式中。 Tier 引入了拓扑上的规定哪些组件可以和某个组件交流。 连接件可能只会出现在同一个 tier 或者在相邻的 tier 中。 Multi-Tier 模式在很多 java EE 和 Microsoft .Net 应用中会被发现。 

**缺点:**

1. 成本很大并且非常复杂， 对与小的系统，这样并不划算。

Tier 不是组件，也不是组件的逻辑群组。 也不要把Tier 和 layer 混淆。 layer 是一种实现中的单元和模块， 而tier 是一种运行中的实体。

**优点:**

1. 很容易保障安全行，性能和可用性
2. 也提高了系统的可修改性

下面是一个 multi-tier 架构的实例， 这是一个用 javaEE 技术实现的网站系统。 
<img src="https://exlaw.github.io/assets/img/architecture/img9.png" alt="drawing" width="100%"/>



### Pattern 和 Tactic

1. **Patterns comprise tactics** 

   As we said in the introduction to this chapter, tactics are the “building blocks” of design from which architectural patterns are created. Tactics are atoms and patterns are molecules. Most patterns consist of (are constructed from) several different tactics, and although these tactics might all serve a common purpose— such as promoting modifiability, for example—they are often chosen to promote *different* quality attributes. For example, a tactic might be chosen that makes an availability pattern more secure, or that mitigates the performance impact of a modifiability pattern. 

   Consider the example of the layered pattern, the most common pattern in all of software architecture (virtually all nontrivial systems employ layering). The layered pattern can be seen as the amalgam of several tactics—increase semantic coherence, abstract common services, encapsulate, restrict communication paths, and use an intermediary. For example:

- *Increase semantic coherence*. The goal of ensuring that a layer’s respon- sibilities all work together without excessive reliance on other layers
   is achieved by choosing responsibilities that have semantic coherence. Doing so binds responsibilities that are likely to be affected by a change. For example, responsibilities that deal with hardware should be allocated to a hardware layer and not to an application layer; a hardware respon- sibility typically does not have semantic coherence with the application responsibilities. 
- *Restrict dependencies*. Layers define an ordering and only allow a layer to use the services of its adjacent lower layer. The possible communication paths are reduced to the number of layers minus one. This limitation has a great influence on the dependencies between the layers and makes it much easier to limit the side effects of replacing a layer. 

​      Without any one of its tactics, the pattern might be ineffective. For example, if the restrict dependencies tactic is not employed, then any function in any layer can call any other function in any other layer, destroying the low coupling that makes the layering pattern effective. If the increase semantic coherence tactic is not employed, then functionality could be randomly sprinkled throughout the layers, destroying the separation of concerns, and hence ease of modification, which is the prime motivation for employing layers in the first place. 

2. **using tactics to augment Patterns** 

A pattern is described as a solution to a class of problems in a general context. When a pattern is chosen and applied, the context of its application becomes very specific. A documented pattern is therefore underspecified with respect to applying it in a specific situation. 

To make a pattern work in a given architectural context, we need to examine it from two perspectives: 

1. - The inherent quality attribute tradeoffs that the pattern makes. Patterns exist to achieve certain quality attributes, and we need to compare the ones they promote (and the ones they diminish) with our needs. 
   - Other quality attributes that the pattern isn’t directly concerned with, but which it nevertheless affects, and which are important in our application. 

To illustrate these concerns in particular, and how to use tactics to augment patterns in general, we’ll use the broker pattern as a starting point. 

The broker pattern is widely used in distributed systems and dates back at least to its critical role in CORBA-based systems. Broker is a crucial component of any large-scale, dynamic, service-oriented architecture. 

Using this pattern, a client requesting some information from a server does not need to know the location or APIs of the server. The client simply contacts the broker (typically through a client-side proxy); this is illustrated in the UML sequence diagram in Figure 13.16. 



**Weaknesses of the broker Pattern.** In Section 13.2 we enumerated sev- eral weaknesses of the broker pattern. Here we will examine these weaknesses in more detail. The broker pattern has several weaknesses with respect to certain quality attributes. For example: 

* *Availability*. The broker, if implemented as suggested in Figure 13.6, is a single point of failure. The liveness of servers, the broker, and perhaps even the clients need to be monitored, and repair mechanisms must be provided. 

- *Performance*. The levels of indirection between the client (requesting
   the information or service) and the server (providing the information or service) add overhead, and hence add latency. Also, the broker is a potential performance bottleneck if direct communication between the client and server is not desired (for example, for security reasons). 
- *Testability*. Brokers are employed in complex multi-process and multi- processor systems. Such systems are typically highly dynamic. Requests and responses are typically asynchronous. All of this makes testing and debugging such systems extremely difficult. But the description of the broker pattern provides no testing functionality, such as testing interfaces, state or activity capture and playback capabilities, and so forth. 

Of these quality attributes, the broker pattern is mainly associated with poor performance (the well-documented price for the loose coupling it brings to systems). It is largely unconcerned with the other quality attributes in this list; they aren’t mentioned in most published descriptions. But as the other bullets
show, they can be unacceptable “collateral damage” that come with the broker’s benefits.



**Improving the broker Pattern with tactics.** How can we use tactics to plug the gaps between the “out of the box” broker pattern and a version of it that will let us meet the requirements of a demanding distributed system? Here are some options: 

- The increase available resources performance tactic would lead to multiple brokers, to help with performance and availability. 

- The maintain multiple copies tactic would allow each of these brokers to share state, to ensure that they respond identically to client requests. 

- Load balancing (an application of the scheduling resources tactic) would ensure that one broker is not overloaded while another one sits idle. 

- Heartbeat, exception detection, or ping/echo would give the replicated brokers a way of notifying clients and notifying each other when one of them is out of service, as a means of detecting faults. 

  Of course, each of these tactics brings a tradeoff. Each complicates the de- sign, which will now take longer to implement, be more costly to acquire, and be more costly to maintain. Load balancing introduces indirection that will add latency to each transaction, thus giving back some of the performance it was in- tended to increase. And the load balancer is a single point of failure, so it too must be replicated, further increasing the design cost and complexity. 