# 微服务架构



## 面向服务架构

是一个分布式组件的集合，这些组件为其他组件提供服务，或者消费其他组件所提供的服务，而无需知道其它组件的实现细节。

### 企业服务总线 （ESB）

为服务间的相互调用提供环境支持，路由服务间的消息，并对消息和数据进行必要的转换。

### 服务编排引擎

可以根据预先定义的脚本对服务消费者与服务提供者之间进行指挥。



### 特点

1. 自身高内聚性，服务间松耦合，最小化开发维护中的相互影响
2. 良好的互操作性，符合开放标准
3. 模组化，高重用性
4. 服务动态识别，注册，调用
5. 系统复杂性提高
6. 难以测试验证
7. 各独立服务的演化不可控
8. 中间件易成性能瓶颈

### 面向服务架构实现原则

1. 服务解耦
2. 服务契约
3. 服务封装
4. 服务重用
5. 服务组合
6. 服务自恰
7. 服务无状态



### 优缺点

#### 优点

1. 服务重用性
2. 易维护性
3. 高可靠性
4. 高扩展和可用性
5. 软件质量提升
6. 平台无关
7. 提升效率

#### 缺点

1. 过分使用 ESB 

2. 使用基于 SOAP 协议的 WS

3. 使用形式化的方法管理 ： 管理复杂度高

4. 需要使用可靠的ESB

   





## 微服务架构

微服务架构风格是一种将一个单一应用程序开发为一组小型服务的方法，每个服务运行在自己的进程中，服务间通信采用轻量级通信机制，这些服务围绕业务能力构建并课通过自动部署机制独立部署。



微服务架构的本质仍然是一种分布式架构，也是面向服务架构的一种。



### 微服务架构的特点

1. 通过服务组件化
2. 围绕业务能力组织
3. 内聚和解耦
4. 去中心化
5. 基础设施自动化  Web Services 概念
6. 服务设计 高可用性，变更与演化



### 优缺点

#### 优点

1. 简单
2. 团队独立性
3. 松耦合
4. 平台无关性
5. 通信协议轻量级

#### 缺点

1. 运维成本过高
2. 分布式系统的复杂性
3. 异步，消息与并行方式让开发门槛变高
4. 分布式系统的复杂性也会让系统的测试变得复杂



核心模式

1.服务注册与发现 

1. 启动时注册到服务发现组件

2. 消费者可以从服务发现组建找到提供者的网络地址和接口

  3. 服务与服务发现组件利用一定机制通讯，否则注销
  4. 服务变更会自动重新注册 





2. API网关，单一入口点，针对不同客户端提供不同API 



1. 确保客户端不关心服务划分方式 

2.  客户端不受服务实例位置影响 

3.  提供最优API

4.  降低请求往返次数 

5.  简化客户端 

   



3. 熔断器(模式) 

1.  防止程序不断尝试可能会失败的操作 
2.  使程序诊断错误是否修正，进而再调用 
3.  状态: 

```
闭合:请求能够调用
断开:请求会报错
半断开:一定数量可调用，调用成功则闭合，不成功则断开
```

4. 实现 

### 介绍

**微服务** (Microservices) 是一种 软件架构风格，它是以专注于单一责任与功能的小型功能区块 (Small Building Blocks) 为基础，利用模块化的方式组合出复杂的大型应用程序，各功能区块使用与语言无关 (Language-Independent/Language agnostic) 的 API 集相互通信。

微服务的起源是由 Peter Rodgers 博士于 2005 年度云计算博览会提出的微 Web 服务 (Micro-Web-Service) 开始，Juval Löwy 则是与他有类似的前导想法，将类别变成细粒服务 (granular services)，以作为 [Microsoft](https://zh.wikipedia.org/wiki/Microsoft) 下一阶段的软件架构，其核心想法是让服务是由类似 Unix 管道的访问方式使用，而且复杂的服务背后是使用简单 [URI](https://zh.wikipedia.org/wiki/URI) 来开放接口，任何服务，任何细粒都能被开放 (exposed)。这个设计在 HP 的实验室被实现，具有改变复杂软件系统的强大力量。

2014年，[Martin Fowler](https://zh.wikipedia.org/wiki/Martin_Fowler) 与 [James Lewis](https://zh.wikipedia.org/w/index.php?title=James_Lewis&action=edit&redlink=1) 共同提出了微服务的概念，定义了微服务是由以单一应用程序构成的小服务，自己拥有自己的行程与轻量化处理，服务依业务功能设计，以全自动的方式部署，与其他服务使用 HTTP API 通信。同时服务会使用最小的规模的集中管理 (例如 [Docker](https://zh.wikipedia.org/wiki/Docker)) 能力，服务可以用不同的编程语言与数据库等组件实现[[1\]](https://zh.wikipedia.org/wiki/%E5%BE%AE%E6%9C%8D%E5%8B%99#cite_note-1)。



### 概念

微服务是一种以业务功能为主的服务设计概念，每一个服务都具有自主运行的业务功能，对外开放不受语言限制的 API (最常用的是 HTTP)，应用程序则是由一个或多个微服务组成。

微服务的另一个对比是**单体式应用程序**。单体式应用表示一个应用程序内包含了所有需要的业务功能，并且使用像[主从式架构](https://zh.wikipedia.org/wiki/%E4%B8%BB%E5%BE%9E%E5%BC%8F%E6%9E%B6%E6%A7%8B)(Client/Server) 或是[多层次架构](https://zh.wikipedia.org/w/index.php?title=%E5%A4%9A%E5%B1%A4%E6%AC%A1%E6%9E%B6%E6%A7%8B&action=edit&redlink=1) (N-tier) 实现，虽然它也是能以分布式应用程序来实现，但是在单体式应用内，每一个业务功能是不可分割的。若要对单体式应用进行扩展则必须将**整个**应用程序都放到新的运算资源（如：虚拟机） 内，但事实上应用程序中最吃资源、需要运算资源的仅有某个业务部分（例如跑分析报表或是数学算法分析），但因为单体式应用无法分割该部分，因此无形中会有大量的资源浪费的现象。

微服务运用了以业务功能的设计概念，应用程序在设计时就能先以业务功能或流程设计先行分割，将各个业务功能都独立实现成一个能自主运行的个体服务，然后再利用相同的协议将所有应用程序需要的服务都组合起来，形成一个应用程序。若需要针对特定业务功能进行扩展时，只要对该业务功能的服务进行扩展就好，不需要整个应用程序都扩展，同时，由于微服务是以业务功能导向的实现，因此不会受到应用程序的干扰，微服务的管理员可以视运算资源的需要来配置微服务到不同的运算资源内，或是布建新的运算资源并将它配置进去。

虽然使用一般的[服务器虚拟化](https://zh.wikipedia.org/w/index.php?title=%E4%BC%BA%E6%9C%8D%E5%99%A8%E8%99%9B%E6%93%AC%E5%8C%96&action=edit&redlink=1)技术就能应用于微服务的管理，但容器技术 (Container Technology) 如 [Docker](https://zh.wikipedia.org/wiki/Docker) 会更加地适合发展微服务的运算资源管理技术。



### 规划

微服务的规划与**单体式应用程序**十分不同，微服务中每个服务都需要避免与其他服务有所牵连，且都要能够自主，并在其他服务发生错误时不受干扰。



#### 数据库

微服务理念中有数个数据库的规划方式。

- 每个服务都各有一个数据库，同属性的服务可共享同个数据库。
- 所有服务都共享同个数据库，但是不同表格，并且不会跨域访问。
- 每个服务都有自己的数据库，就算是同属性的服务也是，数据库并不会共享。

数据库并不会只存放该服务的数据，而是“**该服务所会用到的所有数据**”。更深层一点的举例：假设有个文章服务，而这个服务可能会需要判断用户的账号⋯⋯等。那么文章服务的数据库就可以放入用户的部分数据。此举是为了避免服务之间的相依性，避免文章服务调用用户服务。

####数据库的可弃性

实践微服务有许多的做法，但其中一种做法是将数据库作为**短期**的存储空间而不是存储长期的数据。这意味着数据库可以在离线时被清空。因为它们可以在上线时从事件存储中心恢复，因此也能以存储器缓存（如：[Redis](https://zh.wikipedia.org/wiki/Redis)） 作为数据库服务器。但这种做法需要将每个请求当作事件来进行广播。如此一来就可以从事件存储中心重播所有的事件来找回所有的数据。

#### 沟通与事件广播

NSQ 是一个消息队列系统、平台。在微服务中所扮演的角色是将消息、数据传递到其他服务。 此举是异步运行，所以不需要等到其他服务接收到消息就能够运行下一步。这种方式能够避免服务之间有所牵连、调用。

微服务中最重要的就是每个服务的独立与自主，因此服务与服务之间也**不应该**有所沟通。倘若真有沟通，也应采用异步沟通的方式来避免紧密的相依性问题。要达到此目的，则可用下列两种方式：

#### 事件存储中心（Event Store

这可以让你在服务集群中广播事件，并且在每个服务中监听这些事件并作处理，这令服务之间没有紧密的相依性，而这些发生的事件都会被保存在事件存储中心里。这意味着当微服务重新上线、部署时可以重播（Replay）所有的事件。这也造就了微服务的数据库随时都可以被删除、摧毁，且不需要从其他服务中获取数据。

#### 消息队列（Message Queue

这令你能够在服务集群中广播消息，并传递到每个服务中。具有这个功能的像是 NSQ 或是 [RabbitMQ](https://zh.wikipedia.org/wiki/RabbitMQ)。你能够在 A 服务上广播一个“创建新用户”的事件，这个事件可以顺便**带有**新用户的数据。而 B 服务可以**监听**这个事件并在接收到之后有所处理。这些过程都是异步处理的，这意味着 A 服务并不需要等到 B 服务处理完该事件后才能继续，而这也代表 A 服务无法获取 B 服务的处理结果。与事件存储中心近乎相似，但有所不同的是：消息队列并**不会**保存事件。一旦事件被消化（接收）后就会从队列中消失，这很适合用在像发送欢迎信件的时机。

#### 服务探索

单个微服务在上线的时候，会向服务探索中心（如：Consul）注册自己的 IP 位置、服务内容，如此一来就不需要向每个微服务表明自己的 IP 位置，也就不用替每个微服务单独设置。当服务需要调用另一个服务的时候，会去询问服务探索中心该服务的 IP 位置为何，得到位置后即可直接向目标服务调用。

这么做的用意是可以统一集中所有服务的位置，就不会分散于每个微服务中，且服务探索中心可以每隔一段时间就向微服务进行健康检查（如透过：TCP 调用、HTTP 调用、Ping），倘若该服务在时间内没有回应，则将其从服务中心移除，避免其他微服务对一个无回应的服务进行调用。



### 内容

一个微服务框架的应用程序有下列特性：

- 每个服务都容易被取代。
- 服务是以能力来组织的，例如用户界面、前端、推荐系统、账单或是物流等。
- 由于功能被拆成多个服务，因此可以由不同的编程语言、数据库实现。
- 架构是对称而非分层（即生产者与消费者的关系）。

一个微服务框架：

- 适用于具持续交付 (Continuous Delivery) 的软件开发流程。
- 与[服务导向架构](https://zh.wikipedia.org/wiki/%E6%9C%8D%E5%8B%99%E5%B0%8E%E5%90%91%E6%9E%B6%E6%A7%8B) (Service-Oriented Architecture) 不同，后者是集成各种业务的应用程序，但微服务只属于一个应用程序。